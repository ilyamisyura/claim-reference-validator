/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Fastapi-Nuxt Template
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  HTTPValidationError,
  ListProjectsParams,
  PaginatedResponseProjectOut,
  ProjectCreate,
  ProjectOut,
  ProjectUpdate
} from '../models';






/**
 * @summary List Projects
 */
export const listProjects = (
    params?: MaybeRef<ListProjectsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedResponseProjectOut>> => {
    params = unref(params);
    
    return axios.default.get(
      `/api/v1/projects/`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }




export const getListProjectsQueryKey = (params?: MaybeRef<ListProjectsParams>,) => {
    return [
    'api','v1','projects', ...(params ? [params]: [])
    ] as const;
    }

    
export const getListProjectsQueryOptions = <TData = Awaited<ReturnType<typeof listProjects>>, TError = AxiosError<HTTPValidationError>>(params?: MaybeRef<ListProjectsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getListProjectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjects>>> = ({ signal }) => listProjects(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData> 
}

export type ListProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof listProjects>>>
export type ListProjectsQueryError = AxiosError<HTTPValidationError>


/**
 * @summary List Projects
 */

export function useListProjects<TData = Awaited<ReturnType<typeof listProjects>>, TError = AxiosError<HTTPValidationError>>(
 params?: MaybeRef<ListProjectsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListProjectsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}




/**
 * @summary Create Project
 */
export const createProject = (
    projectCreate: MaybeRef<ProjectCreate>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProjectOut>> => {
    projectCreate = unref(projectCreate);
    
    return axios.default.post(
      `/api/v1/projects/`,
      projectCreate,options
    );
  }



export const getCreateProjectMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: ProjectCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: ProjectCreate}, TContext> => {

const mutationKey = ['createProject'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProject>>, {data: ProjectCreate}> = (props) => {
          const {data} = props ?? {};

          return  createProject(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof createProject>>>
    export type CreateProjectMutationBody = ProjectCreate
    export type CreateProjectMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Project
 */
export const useCreateProject = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: ProjectCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createProject>>,
        TError,
        {data: ProjectCreate},
        TContext
      > => {

      const mutationOptions = getCreateProjectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get Project
 */
export const getProject = (
    projectId: MaybeRef<number>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProjectOut>> => {
    projectId = unref(projectId);
    
    return axios.default.get(
      `/api/v1/projects/${projectId}`,options
    );
  }




export const getGetProjectQueryKey = (projectId?: MaybeRef<number>,) => {
    return [
    'api','v1','projects',projectId
    ] as const;
    }

    
export const getGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<HTTPValidationError>>(projectId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getGetProjectQueryKey(projectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(projectId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(projectId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> 
}

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Project
 */

export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = AxiosError<HTTPValidationError>>(
 projectId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProjectQueryOptions(projectId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}




/**
 * @summary Update Project
 */
export const updateProject = (
    projectId: MaybeRef<number>,
    projectUpdate: MaybeRef<ProjectUpdate>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProjectOut>> => {
    projectId = unref(projectId);
projectUpdate = unref(projectUpdate);
    
    return axios.default.put(
      `/api/v1/projects/${projectId}`,
      projectUpdate,options
    );
  }



export const getUpdateProjectMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{projectId: number;data: ProjectUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{projectId: number;data: ProjectUpdate}, TContext> => {

const mutationKey = ['updateProject'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProject>>, {projectId: number;data: ProjectUpdate}> = (props) => {
          const {projectId,data} = props ?? {};

          return  updateProject(projectId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateProject>>>
    export type UpdateProjectMutationBody = ProjectUpdate
    export type UpdateProjectMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Project
 */
export const useUpdateProject = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{projectId: number;data: ProjectUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateProject>>,
        TError,
        {projectId: number;data: ProjectUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateProjectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete Project
 */
export const deleteProject = (
    projectId: MaybeRef<number>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    projectId = unref(projectId);
    
    return axios.default.delete(
      `/api/v1/projects/${projectId}`,options
    );
  }



export const getDeleteProjectMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{projectId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{projectId: number}, TContext> => {

const mutationKey = ['deleteProject'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProject>>, {projectId: number}> = (props) => {
          const {projectId} = props ?? {};

          return  deleteProject(projectId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProject>>>
    
    export type DeleteProjectMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Project
 */
export const useDeleteProject = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{projectId: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deleteProject>>,
        TError,
        {projectId: number},
        TContext
      > => {

      const mutationOptions = getDeleteProjectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    