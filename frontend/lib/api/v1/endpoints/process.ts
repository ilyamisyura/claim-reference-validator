/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Fastapi-Nuxt Template
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/vue-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationReturnType
} from '@tanstack/vue-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import {
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  BodyProcessPdf,
  DoclingPDFToMarkdownResponse,
  HTTPValidationError,
  ProcessPdfParams,
  ReferencesExtractionRequest,
  ReferencesExtractionResponse,
  TextExtractionRequest,
  TextExtractionResponse
} from '../models';






/**
 * Process PDF document and extract markdown.

This endpoint:
1. Converts PDF to clean Markdown format using Docling
2. Stores the markdown in the database for later RAG processing
3. Returns the markdown for viewing and manual reference selection

Args:
    project_id: Project ID to associate the document with
    file: PDF file upload
    session: Database session

Returns:
    Document ID and markdown content
 * @summary Process Pdf
 */
export const processPdf = (
    bodyProcessPdf: MaybeRef<BodyProcessPdf>,
    params: MaybeRef<ProcessPdfParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DoclingPDFToMarkdownResponse>> => {
    bodyProcessPdf = unref(bodyProcessPdf);
params = unref(params);
    const formData = new FormData();
formData.append(`file`, bodyProcessPdf.file)

    return axios.default.post(
      `/api/v1/process/pdf`,
      formData,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }



export const getProcessPdfMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processPdf>>, TError,{data: BodyProcessPdf;params: ProcessPdfParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof processPdf>>, TError,{data: BodyProcessPdf;params: ProcessPdfParams}, TContext> => {

const mutationKey = ['processPdf'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processPdf>>, {data: BodyProcessPdf;params: ProcessPdfParams}> = (props) => {
          const {data,params} = props ?? {};

          return  processPdf(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessPdfMutationResult = NonNullable<Awaited<ReturnType<typeof processPdf>>>
    export type ProcessPdfMutationBody = BodyProcessPdf
    export type ProcessPdfMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Process Pdf
 */
export const useProcessPdf = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processPdf>>, TError,{data: BodyProcessPdf;params: ProcessPdfParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof processPdf>>,
        TError,
        {data: BodyProcessPdf;params: ProcessPdfParams},
        TContext
      > => {

      const mutationOptions = getProcessPdfMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Extract claims and references from text using LM Studio.

This endpoint:
1. Uses LLM to extract claims and references from the provided text
2. Deduplicates references against existing database entries
3. Creates new claims linked to the project
4. Links claims to their supporting references

Args:
    request: Text extraction request with text and project_id
    session: Database session

Returns:
    Extraction response with statistics
 * @summary Process Text
 */
export const extractClaimsAndReferences = (
    textExtractionRequest: MaybeRef<TextExtractionRequest>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TextExtractionResponse>> => {
    textExtractionRequest = unref(textExtractionRequest);
    
    return axios.default.post(
      `/api/v1/process/text`,
      textExtractionRequest,options
    );
  }



export const getExtractClaimsAndReferencesMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractClaimsAndReferences>>, TError,{data: TextExtractionRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof extractClaimsAndReferences>>, TError,{data: TextExtractionRequest}, TContext> => {

const mutationKey = ['extractClaimsAndReferences'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractClaimsAndReferences>>, {data: TextExtractionRequest}> = (props) => {
          const {data} = props ?? {};

          return  extractClaimsAndReferences(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractClaimsAndReferencesMutationResult = NonNullable<Awaited<ReturnType<typeof extractClaimsAndReferences>>>
    export type ExtractClaimsAndReferencesMutationBody = TextExtractionRequest
    export type ExtractClaimsAndReferencesMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Process Text
 */
export const useExtractClaimsAndReferences = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractClaimsAndReferences>>, TError,{data: TextExtractionRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof extractClaimsAndReferences>>,
        TError,
        {data: TextExtractionRequest},
        TContext
      > => {

      const mutationOptions = getExtractClaimsAndReferencesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Extract only references from text using LM Studio.

This endpoint:
1. Uses LLM to extract references from the provided text
2. Deduplicates references against existing database entries
3. Creates new reference records

Args:
    request: References extraction request with text and project_id
    session: Database session

Returns:
    Extraction response with statistics
 * @summary Process References
 */
export const extractReferences = (
    referencesExtractionRequest: MaybeRef<ReferencesExtractionRequest>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReferencesExtractionResponse>> => {
    referencesExtractionRequest = unref(referencesExtractionRequest);
    
    return axios.default.post(
      `/api/v1/process/references`,
      referencesExtractionRequest,options
    );
  }



export const getExtractReferencesMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractReferences>>, TError,{data: ReferencesExtractionRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof extractReferences>>, TError,{data: ReferencesExtractionRequest}, TContext> => {

const mutationKey = ['extractReferences'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractReferences>>, {data: ReferencesExtractionRequest}> = (props) => {
          const {data} = props ?? {};

          return  extractReferences(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractReferencesMutationResult = NonNullable<Awaited<ReturnType<typeof extractReferences>>>
    export type ExtractReferencesMutationBody = ReferencesExtractionRequest
    export type ExtractReferencesMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Process References
 */
export const useExtractReferences = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractReferences>>, TError,{data: ReferencesExtractionRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof extractReferences>>,
        TError,
        {data: ReferencesExtractionRequest},
        TContext
      > => {

      const mutationOptions = getExtractReferencesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    