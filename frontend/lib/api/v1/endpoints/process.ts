/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Fastapi-Nuxt Template
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/vue-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationReturnType
} from '@tanstack/vue-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import {
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  BodyProcessPdfApiV1ProcessPdfPost,
  DoclingPDFToMarkdownResponse,
  HTTPValidationError,
  ProcessPdfApiV1ProcessPdfPostParams,
  TextExtractionRequest,
  TextExtractionResponse
} from '../models';






/**
 * Process PDF document and extract markdown.

This endpoint:
1. Converts PDF to clean Markdown format using Docling
2. Stores the markdown in the database for later RAG processing
3. Returns the markdown for viewing and manual reference selection

Args:
    project_id: Project ID to associate the document with
    file: PDF file upload
    session: Database session

Returns:
    Document ID and markdown content
 * @summary Process Pdf
 */
export const processPdfApiV1ProcessPdfPost = (
    bodyProcessPdfApiV1ProcessPdfPost: MaybeRef<BodyProcessPdfApiV1ProcessPdfPost>,
    params: MaybeRef<ProcessPdfApiV1ProcessPdfPostParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DoclingPDFToMarkdownResponse>> => {
    bodyProcessPdfApiV1ProcessPdfPost = unref(bodyProcessPdfApiV1ProcessPdfPost);
params = unref(params);
    const formData = new FormData();
formData.append(`file`, bodyProcessPdfApiV1ProcessPdfPost.file)

    return axios.default.post(
      `/api/v1/process/pdf`,
      formData,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }



export const getProcessPdfApiV1ProcessPdfPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processPdfApiV1ProcessPdfPost>>, TError,{data: BodyProcessPdfApiV1ProcessPdfPost;params: ProcessPdfApiV1ProcessPdfPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof processPdfApiV1ProcessPdfPost>>, TError,{data: BodyProcessPdfApiV1ProcessPdfPost;params: ProcessPdfApiV1ProcessPdfPostParams}, TContext> => {

const mutationKey = ['processPdfApiV1ProcessPdfPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processPdfApiV1ProcessPdfPost>>, {data: BodyProcessPdfApiV1ProcessPdfPost;params: ProcessPdfApiV1ProcessPdfPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  processPdfApiV1ProcessPdfPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessPdfApiV1ProcessPdfPostMutationResult = NonNullable<Awaited<ReturnType<typeof processPdfApiV1ProcessPdfPost>>>
    export type ProcessPdfApiV1ProcessPdfPostMutationBody = BodyProcessPdfApiV1ProcessPdfPost
    export type ProcessPdfApiV1ProcessPdfPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Process Pdf
 */
export const useProcessPdfApiV1ProcessPdfPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processPdfApiV1ProcessPdfPost>>, TError,{data: BodyProcessPdfApiV1ProcessPdfPost;params: ProcessPdfApiV1ProcessPdfPostParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof processPdfApiV1ProcessPdfPost>>,
        TError,
        {data: BodyProcessPdfApiV1ProcessPdfPost;params: ProcessPdfApiV1ProcessPdfPostParams},
        TContext
      > => {

      const mutationOptions = getProcessPdfApiV1ProcessPdfPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Extract claims and references from text using LM Studio.

This endpoint:
1. Uses LLM to extract claims and references from the provided text
2. Deduplicates references against existing database entries
3. Creates new claims linked to the project
4. Links claims to their supporting references

Args:
    request: Text extraction request with text and project_id
    session: Database session

Returns:
    Extraction response with statistics
 * @summary Process Text
 */
export const processTextApiV1ProcessTextPost = (
    textExtractionRequest: MaybeRef<TextExtractionRequest>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TextExtractionResponse>> => {
    textExtractionRequest = unref(textExtractionRequest);
    
    return axios.default.post(
      `/api/v1/process/text`,
      textExtractionRequest,options
    );
  }



export const getProcessTextApiV1ProcessTextPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processTextApiV1ProcessTextPost>>, TError,{data: TextExtractionRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof processTextApiV1ProcessTextPost>>, TError,{data: TextExtractionRequest}, TContext> => {

const mutationKey = ['processTextApiV1ProcessTextPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processTextApiV1ProcessTextPost>>, {data: TextExtractionRequest}> = (props) => {
          const {data} = props ?? {};

          return  processTextApiV1ProcessTextPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessTextApiV1ProcessTextPostMutationResult = NonNullable<Awaited<ReturnType<typeof processTextApiV1ProcessTextPost>>>
    export type ProcessTextApiV1ProcessTextPostMutationBody = TextExtractionRequest
    export type ProcessTextApiV1ProcessTextPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Process Text
 */
export const useProcessTextApiV1ProcessTextPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processTextApiV1ProcessTextPost>>, TError,{data: TextExtractionRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof processTextApiV1ProcessTextPost>>,
        TError,
        {data: TextExtractionRequest},
        TContext
      > => {

      const mutationOptions = getProcessTextApiV1ProcessTextPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    